use anyhow::Result;
use cargo_metadata::MetadataCommand;
use regex::Regex;
use std::collections::{BTreeMap, HashSet};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

#[derive(serde::Serialize, Debug, Clone, PartialEq)]
pub struct FeatureSet {
    pub enabled: Vec<String>,
    pub unused: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dangling: Option<Vec<String>>,
}

/// Analyze dependency feature usage for a project
pub fn analyze_features(
    manifest_path: Option<PathBuf>,
    target: Option<&str>,
) -> Result<BTreeMap<String, FeatureSet>> {
    let mut cmd = MetadataCommand::new();
    if let Some(path) = manifest_path {
        cmd.manifest_path(path);
    }
    if let Some(target) = target {
        cmd.other_options(vec!["--filter-platform".to_string(), target.to_string()]);
    }

    let metadata = cmd.exec()?;
    let mut features_map: BTreeMap<String, FeatureSet> = BTreeMap::new();

    if let Some(resolve) = metadata.resolve {
        for node in resolve.nodes {
            let package = metadata
                .packages
                .iter()
                .find(|p| p.id == node.id)
                .expect("Package not found in metadata");

            // Only check for dangling features if the package is a workspace member
            let is_workspace_member = metadata.workspace_members.contains(&package.id);

            let mut enabled_features = node.features.clone();
            enabled_features.sort();

            let mut unused_features: Vec<String> = package
                .features
                .keys()
                .filter(|f| !enabled_features.contains(f))
                .cloned()
                .collect();
            unused_features.sort();

            let mut dangling_features = Vec::new();
            if is_workspace_member {
                let package_root = package.manifest_path.parent().unwrap().as_std_path();
                let used_in_code = scan_feature_usages(package_root)?;

                for (feature, deps) in &package.features {
                    // A feature is dangling if:
                    // 1. It has no dependencies (does not enable other features)
                    // 2. AND it is not used in the code
                    if deps.is_empty() && !used_in_code.contains(feature) {
                        dangling_features.push(feature.clone());
                    }
                }
                dangling_features.sort();
            }

            // Simple collision handling: append version if collision
            let key = if features_map.contains_key(&package.name) {
                format!("{}@{}", package.name, package.version)
            } else {
                package.name.clone()
            };

            features_map.insert(
                key,
                FeatureSet {
                    enabled: enabled_features,
                    unused: unused_features,
                    dangling: if dangling_features.is_empty() {
                        None
                    } else {
                        Some(dangling_features)
                    },
                },
            );
        }
    }

    Ok(features_map)
}

/// Scan code for feature usage
pub fn scan_feature_usages(root: &Path) -> Result<HashSet<String>> {
    let mut used_features = HashSet::new();
    let re = Regex::new(r#"feature\s*=\s*"([^"]+)""#)?;

    for entry in WalkDir::new(root)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path().extension().is_some_and(|ext| ext == "rs")
                && !e.path().components().any(|c| c.as_os_str() == "target")
        })
    {
        let content = std::fs::read_to_string(entry.path())?;
        for cap in re.captures_iter(&content) {
            if let Some(m) = cap.get(1) {
                used_features.insert(m.as_str().to_string());
            }
        }
    }

    Ok(used_features)
}

/// Generate TOML output with header comments
pub fn generate_toml_output(features_map: &BTreeMap<String, FeatureSet>) -> Result<String> {
    let mut output_content = String::new();

    // Add file header comments
    output_content.push_str("# Cargo Features Report\n");
    output_content.push_str("# Generated by cargo-about-features\n");
    output_content.push_str(
        "# This file lists the feature usage status for all dependencies in your project\n",
    );
    output_content.push_str("# \n");
    output_content.push_str("# Format:\n");
    output_content.push_str("# [package_name] - Features are grouped into three categories:\n");
    output_content.push_str("#   enabled: Features that are currently enabled and in use\n");
    output_content.push_str("#   unused: Features that are available but not enabled\n");
    output_content.push_str(
        "#   dangling: Features that are defined but have no effect (workspace members only)\n",
    );
    output_content.push_str("# \n");
    output_content.push_str(
        "# Note: Package names may include version numbers (e.g., \"package@1.2.3\") to handle\n",
    );
    output_content.push_str("#       cases where multiple versions of the same package are used\n");
    output_content.push('\n');

    // Generate TOML content
    let toml_string = toml::to_string_pretty(features_map)?;
    output_content.push_str(&toml_string);

    Ok(output_content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_scan_feature_usages() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");

        fs::write(
            &test_file,
            r#"
            fn main() {
                if cfg!(feature = "test-feature") {
                    println!("test");
                }
                
                #[cfg(feature = "another-feature")]
                {
                    // some code
                }
            }
        "#,
        )
        .unwrap();

        let result = scan_feature_usages(temp_dir.path()).unwrap();

        assert!(result.contains("test-feature"));
        assert!(result.contains("another-feature"));
        assert_eq!(result.len(), 2);
    }

    #[test]
    fn test_scan_feature_usages_no_matches() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");

        fs::write(
            &test_file,
            r#"
            fn main() {
                println!("no features here");
            }
        "#,
        )
        .unwrap();

        let result = scan_feature_usages(temp_dir.path()).unwrap();
        assert_eq!(result.len(), 0);
    }

    #[test]
    fn test_generate_toml_output() {
        let mut features_map = BTreeMap::new();
        features_map.insert(
            "test-package".to_string(),
            FeatureSet {
                enabled: vec!["feature1".to_string(), "feature2".to_string()],
                unused: vec!["feature3".to_string()],
                dangling: None,
            },
        );

        let output = generate_toml_output(&features_map).unwrap();

        // Verify header comments
        assert!(output.contains("# Cargo Features Report"));
        assert!(output.contains("# Generated by cargo-about-features"));
        assert!(output.contains("enabled: Features that are currently enabled and in use"));
        assert!(output.contains("unused: Features that are available but not enabled"));
        assert!(output.contains(
            "dangling: Features that are defined but have no effect (workspace members only)"
        ));

        // Verify TOML content
        assert!(output.contains("[test-package]"));
        assert!(output.contains("enabled = ["));
        assert!(output.contains("\"feature1\""));
        assert!(output.contains("\"feature2\""));
        assert!(output.contains("unused = ["));
        assert!(output.contains("\"feature3\""));

        // Extract just the TOML part (after header comments)
        let toml_start = output.find("[test-package]").unwrap();
        let toml_part = &output[toml_start..];

        // Should not contain dangling field in TOML when None
        assert!(!toml_part.contains("dangling"));
    }

    #[test]
    fn test_feature_set_serialization() {
        let feature_set_with_dangling = FeatureSet {
            enabled: vec!["serde".to_string(), "std".to_string()],
            unused: vec!["debug".to_string()],
            dangling: Some(vec!["deprecated".to_string()]),
        };

        let serialized = toml::to_string(&feature_set_with_dangling).unwrap();

        assert!(serialized.contains("enabled = ["));
        assert!(serialized.contains("\"serde\""));
        assert!(serialized.contains("\"std\""));
        assert!(serialized.contains("unused = ["));
        assert!(serialized.contains("\"debug\""));
        assert!(serialized.contains("dangling = ["));
        assert!(serialized.contains("\"deprecated\""));
    }

    #[test]
    fn test_feature_set_serialization_without_dangling() {
        let feature_set_no_dangling = FeatureSet {
            enabled: vec!["serde".to_string()],
            unused: vec!["debug".to_string()],
            dangling: None,
        };

        let serialized = toml::to_string(&feature_set_no_dangling).unwrap();

        assert!(serialized.contains("enabled = ["));
        assert!(serialized.contains("\"serde\""));
        assert!(serialized.contains("unused = ["));
        assert!(serialized.contains("\"debug\""));
        // Should not contain dangling field when None
        assert!(!serialized.contains("dangling"));
    }
}
